#' Functions for extracting covariates in a array/ data.table format

#' @title Extract covariate in array format, with dimensions: GridID, Covariate, Time
#' @param cov_type: covariate types, either "constant", "temporal" or "both". "both" by default
#' @param dates: list of date intervals, generated by `fcn_date_intervals`. Defaults to start from 1994-10-01 to present in 6-month intervals
#' @param time_lag: if cov_type is not "constant", computes additional time-lag variables by number of months specified in an array of months (e.g. time_lag = c(6,12) for computing both 6 month and 12 month time lags). No time lags computed by default (i.e. time_lag = NULL)
#' @export
fcn_cov_array <- function(cov_type = "both", dates = NULL, time_lag = NULL) {

  # Determine which variables to compute
  compute_constant <- cov_type %in% c("constant", "both")
  compute_temporal <- cov_type %in% c("temporal", "both")

  # Get date interval list object
  if (is.null(dates)) {
    dates <- fcn_date_intervals()
  }

  # Output list object
  output <- list()

  # Get covariate names
  cov_layer_df <- fcn_get_covariate_df()

  # Compute constant variables
  if (compute_constant) {
    cov_constant_names <- cov_layer_df[cov_layer_df$type == 'constant','filename']
    cov_constant <- fcn_extract_covariate_grid(cov_constant_names)
    cov_constant_df <- fcn_cov_grid_df(cov_constant)
    output$cov_constant <- cov_constant_df
  }

  # Compute temporal variables
  if (compute_temporal) {
    cov_temporal_names <- cov_layer_df[cov_layer_df$type == 'temporal','name'] %>%
      unique()

    # Apply function for each of the dates
    fcn_extract_cov_date <- function(d) {
      print(sprintf("Processing covariates for date starting %s", d$start_date))
      # Apply for each of the covariate names
      covs <- purrr::map(cov_temporal_names, ~ fcn_covariate_interval_mean(d, .))
      cov_comb <- purrr::reduce(covs, dplyr::inner_join, by = "GridID")

      # Compute lagged variables and join back to the dataframe
      if (!is.null(time_lag)) {
        for (lag in time_lag) {
          d_lag <- fcn_shift_months(d, -lag) # date object lagged
          covs_lag <- purrr::map(cov_temporal_names, ~ fcn_covariate_interval_mean(d_lag, .))
          cov_lag_comb <- purrr::reduce(covs_lag, dplyr::inner_join, by = "GridID")
          colnames(cov_lag_comb)[2:ncol(cov_lag_comb)] <- paste0(colnames(cov_lag_comb)[2:ncol(cov_lag_comb)],
                                                              "_",
                                                              lag, "mths")
          cov_comb <- dplyr::inner_join(cov_comb, cov_lag_comb, by = "GridID")
        }
      }
      return(cov_comb)
    }

    # Loop over all dates
    cov_temporal <- purrr::map(dates, fcn_extract_cov_date)

    # Combine output
    cov_temporal_df <- abind::abind(cov_temporal)

    # Set the output to the list
    output$cov_temporal <- cov_temporal
  }

  return(output)
}

#' @title Get mean values of each Grid cell given the name of covariate and a single date
#' @param date: a list object from `fcn_date_intervals` containing: interval, start_date, end_date, middle_date
#' @param cov_name: name of the covariate (excluding dates of the covariate layer)
#' @export
fcn_covariate_interval_mean <- function(date, cov_name) {
  cov_layer_df <- fcn_get_covariate_df()
  cov_layer_df_name <- cov_layer_df[cov_layer_df$name == cov_name,]
  cov_dates <- cov_layer_df_name$date
  cov_dates_num <- gsub(".*[^0-9]([0-9]{6})[^0-9]*", "\\1", cov_dates) %>%
    as.numeric() %>%
    lubridate::ym()
  within_interval <- cov_dates_num %within% date$interval
  if (sum(within_interval) > 0) {
    cov_layer_list <- cov_layer_df_name[within_interval,'filename']
  } else {
    # If no covariates fall in the interval, grab the one closest to the midpoint of the interval
    nearest_date <- which.min(abs(cov_dates_num - date$middle_date))
    cov_layer_list <- cov_layer_df_name[nearest_date,'filename']
  }
  cov_temporal <- fcn_extract_covariate_grid(cov_layer_list)
  cov_temporal_df <- fcn_cov_grid_df(cov_temporal)
  cov_temporal_mean <- cov_temporal_df[,2:ncol(cov_temporal_df)]
  if (ncol(cov_temporal_df) > 2) {
    cov_temporal_mean <- rowMeans(cov_temporal_mean)
  }
  cov_df_output <- data.frame(GridID = cov_temporal_df$GridID)
  cov_df_output[cov_name] <- cov_temporal_mean
  return(cov_df_output)
}

#' @title Get dates from start to end in an interval format
#' @param start_date: start date
#' @param end_date: end date (if NULL, taken as the current date)
#' @param interval_months: interval in months ("6 months", or "12 months")
#' @export
fcn_date_intervals <- function(start_date = "1994-10-01", end_date = NULL, interval_months= 6) {
  library(lubridate)

  # Define the start date (October 1994)
  start_date <- lubridate::ymd(start_date, tz = Sys.timezone())

  # Get the current date
  if (is.null(end_date) || is.na(end_date)) {
    end_date <- lubridate::ymd(Sys.Date() %m+% months(interval_months) %m-% days(1), tz = Sys.timezone())
  }

  # Create a sequence of 6-month intervals
  interval_starts <- seq(start_date, end_date, by = paste(interval_months, "months"))

  # Remove last start date
  interval_starts <- interval_starts[1:(length(interval_starts)-1)]

  # Get end dates
  interval_ends <- interval_starts + months(interval_months) - seconds(1)

  intervals <- list()
  for (i in 1:length(interval_starts)) {
    interval_i <- lubridate::interval(interval_starts[i], interval_ends[i])
    start_date_fmt <- format(interval_starts[i], "%Y%m")
    end_date_fmt <- format(interval_ends[i], "%Y%m")
    id = paste0(start_date_fmt, "_", end_date_fmt)
    intervals[[i]] <- list(
      id = id,
      interval = interval_i,
      start_date = interval_starts[i],
      end_date = interval_ends[i],
      middle_date = as.Date(interval_starts[i] + as.duration(lubridate::time_length(interval_i) / 2))
    )
    names(intervals)[i] <- id
  }

  return(intervals)
}

#' @title Shift date intervals object by months
#' @param date_interval: date_interval object from `fcn_date_intervals`
#' @param n_months: number of months to shift forward or backwards (lag). By default computes a 6 month time lag (-6)
#' @export
fcn_shift_months <- function(date_interval, n_months = -6) {
  fcn_shift_month_obj <- function(d) {
    o <- d
    o$start_date = d$start_date %m+% months(n_months)
    o$end_date = d$end_date %m+% months(n_months)
    o$interval = lubridate::interval(d$start_date %m+% months(n_months),
                                     d$end_date %m+% months(n_months))
    o$middle_date <- d$middle_date %m+% months(n_months)
    return(o)
  }
  if (all(sapply(date_interval, is.list))) {
    out <- purrr::map(date_interval, fcn_shift_month_obj)
  } else {
    out <- fcn_shift_month_obj(date_interval)
  }
  return(out)
}
