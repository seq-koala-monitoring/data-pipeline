#' Functions for extracting covariates in a array/ data.table format

#' @title Extract covariate in array format, with dimensions: GridID, Covariate, Time
#' @param cov_type: covariate types, either "constant", "temporal" or "both". "both" by default
#' @param dates: list of date intervals, generated by `fcn_date_intervals`. Defaults to start from 1994-10-01 to present in 6-month intervals
#' @param time_lag: if cov_type is not "constant", computes additional time-lag variables by number of months specified in an array of months (e.g. time_lag = c(6,12) for computing both 6 month and 12 month time lags). No time lags computed by default (i.e. time_lag = NULL)
#' @export
fcn_cov_array <- function(cov_type = "both", dates = NULL, time_lag = NULL, write_path = NULL) {

  # Determine which variables to compute
  compute_constant <- cov_type %in% c("constant", "both")
  compute_temporal <- cov_type %in% c("temporal", "both")

  # Get date interval list object
  if (is.null(dates)) {
    dates <- fcn_get_date_intervals()
  }

  # Output list object
  output <- list()

  # Get covariate names
  cov_layer_df <- fcn_get_covariate_df()

  # Compute constant variables
  if (compute_constant) {
    cov_constant_names <- cov_layer_df[cov_layer_df$type == 'constant','filename']
    cov_constant <- fcn_extract_covariate_grid(cov_constant_names)
    cov_constant_df <- fcn_cov_grid_df(cov_constant)
    output$cov_constant <- cov_constant_df
    if (!is.null(write_path)) {
      saveRDS(cov_constant_df, file = paste0(write_path, "\\cov_constant_array.rds"))
    }
    rm("cov_constant_df")
    gc()
  }

  # Compute temporal variables
  if (compute_temporal) {

    # Apply function for each of the dates


    # Loop over all dates

    #for (i in 1:length(dates)) {
    #  cov_temporal_i <- fcn_extract_cov_date(dates[[i]])
    #  if (i==1) {
    #    cov_temporal_df <- array(data = NA, dim = c(nrow(cov_temporal_i), ncol(cov_temporal_i), length(dates)))
    #  }
    #  cov_temporal_df[,,i] <- cov_temporal_i
    #}

    if (!is.null(write_path)) {

      lapply(dates, \(d) {
        cov_temporal <- fcn_extract_cov_date(d, time_lag=NULL)
        readr::write_rds(cov_temporal, file = paste0(write_path, "\\cov_temporal_", d$id, ".rds"))
        rm(cov_temporal)
      })

    } else {

      cov_temporal <- lapply(dates, \(d) {
        fcn_extract_cov_date(d, time_lag=NULL)
      })
      cov_temporal_array <- do.call(abind::abind, c(cov_temporal, list(along=3)))
      # the output to the list
      output$cov_temporal <- cov_temporal_array
    }
  }

  return(output)
}

#' Extract covariates for a particular date object
#' @param d date object
fcn_extract_cov_date <- function(d, time_lag = NULLL) {
  cov_layer_df <- fcn_get_covariate_df()
  cov_temporal_names <- cov_layer_df[cov_layer_df$type == 'temporal','name'] %>%
    unique()

  print(sprintf("Processing covariates for date starting %s", d$start_date))
  # Apply for each of the covariate names
  covs <- purrr::map(cov_temporal_names, \(x) fcn_covariate_interval_mean(d, x))
  cov_comb <- purrr::reduce(covs, dplyr::full_join, by = "GridID")

  # Compute lagged variables and join back to the dataframe
  if (!is.null(time_lag)) {
    for (lag in time_lag) {
      d_lag <- fcn_shift_months(d, -lag) # date object lagged
      covs_lag <- purrr::map(cov_temporal_names, ~ fcn_covariate_interval_mean(d_lag, .))
      cov_lag_comb <- purrr::reduce(covs_lag, dplyr::inner_join, by = "GridID")
      colnames(cov_lag_comb)[2:ncol(cov_lag_comb)] <- paste0(colnames(cov_lag_comb)[2:ncol(cov_lag_comb)],
                                                             "_",
                                                             lag, "mths")
      cov_comb <- dplyr::inner_join(cov_comb, cov_lag_comb, by = "GridID")
    }
  }
  return(cov_comb)
}

#' @title Get mean values of each Grid cell given the name of covariate and a single date
#' @param date: a list object from `fcn_date_intervals` containing: interval, start_date, end_date, middle_date
#' @param cov_name: name of the covariate (excluding dates of the covariate layer)
#' @param get_df: if TRUE then returns a DataFrame with GridID and the covariate value. If FALSE, returns the covariate raster.
#' @export
fcn_covariate_interval_mean <- function(date, cov_name, get_df = TRUE) {
  cov_layer_df <- fcn_get_covariate_df()
  cov_layer_df_name <- cov_layer_df[cov_layer_df$name == cov_name,]
  cov_categorical <- any(cov_layer_df[cov_layer_df$name == cov_name,] == "Categorical")
  cov_dates <- cov_layer_df_name$date
  cov_dates_num <- gsub(".*[^0-9]([0-9]{6})[^0-9]*", "\\1", cov_dates) %>%
    as.numeric() %>%
    lubridate::ym()
  within_interval <- lubridate::`%within%`(cov_dates_num, date$interval)
  if (sum(within_interval) > 0) {
    cov_layer_list <- cov_layer_df_name[within_interval,'filename']
  } else {
    # If no covariates fall in the interval, grab the one closest to the midpoint of the interval
    nearest_date <- which.min(abs(cov_dates_num - date$middle_date))
    cov_layer_list <- cov_layer_df_name[nearest_date,'filename']
  }

  cov_temporal <- fcn_extract_covariate_grid(cov_layer_list)
  if (length(cov_layer_list) > 1) {
    # Get mean of multiple layers, if continuous
    if (cov_categorical) {
      cov_temporal_mean <- terra::modal(cov_temporal[[2:terra::nlyr(cov_temporal)]], ties = "first")
      # Round categorical values
      cov_temporal_mean <- terra::round(cov_temporal_mean)

    } else {
      cov_temporal_mean <- terra::mean(cov_temporal[[2:terra::nlyr(cov_temporal)]])
    }
    cov_temporal <- c(cov_temporal['GridID'], cov_temporal_mean)
  }

  names(cov_temporal) <- c('GridID', cov_name)

  calc_proportion <- any(cov_layer_df[cov_layer_df$name == cov_name,'Proportions'] == "Yes")

  # Calculate proportions on top of mean/ mode calculations
  if (calc_proportion) {
    cov_temporal_prop <- fcn_extract_covariate_grid(cov_layer_list, proportion = TRUE)
    name_list <- names(cov_temporal_prop[[2:terra::nlyr(cov_temporal_prop)]])
    cov_lyr_names <- stringr::str_split_i(name_list, '_', 1)
    cov_values <- stringr::str_split_i(name_list, '_', 2)

    cov_temporal_mean <- lapply(unique(cov_values), \(x) terra::mean(cov_temporal_prop[name_list[x==cov_values]])) %>%
      terra::rast()
    names(cov_temporal_mean) <- paste(cov_name, unique(cov_values), sep="_")
    cov_temporal <- c(cov_temporal, cov_temporal_mean)
  }

  if (get_df) {
    cov_temporal_df <- fcn_cov_grid_df(cov_temporal)
    return(cov_temporal_df)
  } else {
    return(cov_temporal)
  }
}

#' @title Get dates from start to end in an interval format
#' @param start_date: start date
#' @param end_date: end date (if NULL, taken as the current date)
#' @param interval_months: interval in months ("6 months", or "12 months")
#' @export
fcn_date_intervals <- function(start_date = "1994-10-01", end_date = NULL, interval_months= 6) {
  library(lubridate)

  # Define the start date (October 1994)
  start_date <- lubridate::ymd(start_date, tz = Sys.timezone())

  # Get the current date
  if (is.null(end_date) || is.na(end_date)) {
    end_date <- lubridate::ymd(Sys.Date() %m+% months(interval_months) %m-% days(1), tz = Sys.timezone())
  }

  # Create a sequence of 6-month intervals
  interval_starts <- seq(start_date, end_date, by = paste(interval_months, "months"))

  # Remove last start date
  interval_starts <- interval_starts[1:(length(interval_starts)-1)]

  # Get end dates
  interval_ends <- interval_starts + months(interval_months) - seconds(1)

  intervals <- list()
  for (i in 1:length(interval_starts)) {
    interval_i <- lubridate::interval(interval_starts[i], interval_ends[i])
    start_date_fmt <- format(interval_starts[i], "%Y%m")
    end_date_fmt <- format(interval_ends[i], "%Y%m")
    id = paste0(start_date_fmt, "_", end_date_fmt)
    intervals[[i]] <- list(
      id = id,
      time_period_id = i,
      interval = interval_i,
      start_date = interval_starts[i],
      end_date = interval_ends[i],
      middle_date = as.Date(interval_starts[i] + as.duration(lubridate::time_length(interval_i) / 2))
    )
    names(intervals)[i] <- id
  }

  return(intervals)
}

#' @title Shift date intervals object by months
#' @param date_interval: date_interval object from `fcn_date_intervals`
#' @param n_months: number of months to shift forward or backwards (lag). By default computes a 6 month time lag (-6)
#' @export
fcn_shift_months <- function(date_interval, n_months = -6) {
  fcn_shift_month_obj <- function(d) {
    o <- d
    o$start_date = d$start_date %m+% months(n_months)
    o$end_date = d$end_date %m+% months(n_months)
    o$interval = lubridate::interval(d$start_date %m+% months(n_months),
                                     d$end_date %m+% months(n_months))
    o$middle_date <- d$middle_date %m+% months(n_months)
    return(o)
  }
  if (all(sapply(date_interval, is.list))) {
    out <- purrr::map(date_interval, fcn_shift_month_obj)
  } else {
    out <- fcn_shift_month_obj(date_interval)
  }
  return(out)
}

#' @title Convert RDS of date covariates into a 3-d matrix
#' @param out_dir: directory where the RDS are stored
#'
fcn_temporal_covariate_rds_array <- function(out_dir = NULL, dates = NULL) {
  out_dir_files <- list.files(out_dir, pattern = "cov_temporal_\\d{6}_\\d{6}.rds")
  if (is.null(dates)) {
    dates <- fcn_get_date_intervals()
  }
  for (i in 1:length(dates)) {
    date <- dates[[i]]
    print(paste("Processing covariate date: ", date$id))
    file <- paste0("cov_temporal_", date$id, ".rds")
    if (!(file %in% out_dir_files)) {
      stop(paste("Date", date$id, "does not exist in out_dir."))
    }
    cov <- readRDS(file.path(out_dir, file))
    if (i==1) {
      out <- cov
    } else {
      out <- abind::abind(out, cov)
    }
    rm(cov)
    gc()
  }
  return(out)
}

#' @title Impute missing temporal covariates
#' @param cov: Covariate array
#' @export
fcn_impute_temporal_cov <- function(cov) {
	for (j in 1:ncol(cov)) {
	  complete_cases_cov <- complete.cases(cov[,j,])
	  for (i in which(!complete_cases_cov)) {
  		for (k in which(is.na(cov[i,j,]))) {
  		  if (all(is.na(cov[i,j,]))) next
  		  non_na_id <- (k - 1:dim(cov)[3])[!is.na(cov[i,j,])]
  		  idx <- (1:dim(cov)[3])[!is.na(cov[i,j,])]
  		  if (any(non_na_id > 0)) {
  			kk <- idx[abs(non_na_id) == min(abs(non_na_id[non_na_id > 0]))][1]
  		  } else {
  			kk <- idx[abs(non_na_id) == min(abs(non_na_id))][1]
  		  }
  		  cov[i,j,k] = cov[i,j,kk]
  		}
	  }
	}
  return(cov)
}
