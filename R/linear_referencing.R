#' Linear referencing / dynamic segmentation functions
#' Provides functions to perform linear referencing and dynamic segmentation of line transects.

#' @param feature_class SF object of the grid
#' @param line_transect SF object of the line transect
#' @export
fcn_route_table <- function(feature_class, line_transect) {
  line_transect$length = sf::st_length(line_transect$geom)
  ldnc = sf::st_intersection(line_transect, feature_class)
  start_points <- ldnc[,c('Start_Eastings', 'Start_Northings')] %>%
    sf::st_drop_geometry() %>%
    fcn_df_to_sf()
  ldnc_pts <- sf::st_coordinates(ldnc) %>%
    as.data.frame() %>%
    fcn_df_to_sf()

  # Extract point a and b from ldnc segments
  ldnc_pts_a <- ldnc_pts[seq(1,nrow(ldnc_pts),by=2),]
  ldnc_pts_b <- ldnc_pts[seq(2,nrow(ldnc_pts),by=2),]

  # Get distances for points A and B
  dist_a <- sf::st_distance(start_points, ldnc_pts_a, by_element = T)
  dist_b <- sf::st_distance(start_points, ldnc_pts_b, by_element = T)

  # Calculate start and end points
  ldnc$FMEAS <- units::drop_units(pmin(dist_a, dist_b))
  ldnc$TMEAS <- units::drop_units(pmax(dist_a, dist_b))

  # Return route table
  ldnc$lpercent = units::drop_units((sf::st_length(ldnc)/ldnc$length))
  route_table <- sf::st_drop_geometry(ldnc) %>%
    dplyr::arrange(TransectID, FMEAS)
  return(route_table)
}

# Converts two-column dataframe (Easting and Northing) to SF points
fcn_df_to_sf <- function(df) {
  df_names <- colnames(df)
  points <- df %>%
    sf::st_as_sf(coords = df_names[1:2])
  sf::st_crs(points) <- fcn_get_state()$crs
  return(points)
}

#' Generate reference points and extract covariates
#' #' @param input_raster Input raster (SpatRaster)
#' @param line_transect a `sf` object with fields TransectID (unique id), Tlength (length of transect) -- generated by `fcn_line_transect_sf`
#' @param n number of sample points (including start and finish) for each transect line (precise for (100/n)% of the length -- e.g. n=50 means precise for 2% of the length)
fcn_line_sample_extract_raster <- function(input_raster, line_transect, n = 50) {
  sample_seq <- seq(0,1,length.out=n)
  reference_points <- sf::st_line_sample(line_transect, sample = sample_seq) %>%
    sf::st_cast("POINT") %>%
    sf::st_sf()
  reference_points$TransectID <- rep(line_transect$TransectID, each = n)
  reference_points$Tlength <- rep(line_transect$Tlength, each = n)
  reference_points$Date <- rep(line_transect$Date, each = n)
  reference_points <- reference_points %>%
    dplyr::group_by(TransectID) %>%
    dplyr::mutate(distance_from_start = Tlength * sample_seq[dplyr::row_number()])
  reference_points_vec <- terra::vect(reference_points)
  extract_points <- terra::extract(input_raster, reference_points)
  extract_table <- cbind(reference_points, extract_points)
}

#' Convert covariate sample points to route layer (start and end of covariate value)
#' @param extract_table a sf feature with sampled points, i.e. output of `fcn_line_sample_extract_raster`
#' @param names names of the covariates in the extract_table
fcn_sample_point_to_route <- function(extract_table, names) {
  ## Remove points with same information as the previous column
  # in the multivariate case, it concatenates
  route_table <- extract_table %>%
    dplyr::ungroup() %>%
    tidyr::unite("value", names, remove = FALSE) %>%
    dplyr::mutate(dup = value == dplyr::lag(value) & TransectID == dplyr::lag(TransectID)) %>%
    dplyr::mutate(dup = ifelse(is.na(dup), FALSE, dup)) %>%
    dplyr::filter(!dup) %>%
    dplyr::select(-value) %>%
    dplyr::mutate(distance_to_end = ifelse((dplyr::lead(TransectID) == TransectID) & !is.na(dplyr::lead(TransectID)), dplyr::lead(distance_from_start), Tlength)) %>%
    dplyr::mutate(segment_length = distance_to_end - distance_from_start) %>%
    dplyr::select(TransectID, Date, Tlength, dplyr::all_of(names), distance_from_start, distance_to_end, segment_length, geometry) %>%
    dplyr::mutate(lpercent = segment_length / Tlength) %>%
    dplyr::rename(FMEAS = distance_from_start, TMEAS = distance_to_end)
}

#' Get Route Table (linear referencing) for a series of linear transects
#' @param input_raster Input raster (SpatRaster)
#' @param line_transect a `sf` object with fields TransectID (unique id), Tlength (length of transect) -- generated by `fcn_line_transect_sf`
#' @param n number of sample points (including start and finish) for each transect line (precise for (100/n)% of the length -- e.g. n=50 means precise for 2% of the length)
#' @export
fcn_route_table_raster <- function(input_raster, line_transect, n = 50) {
  extract_table <- fcn_line_sample_extract_raster(input_raster, line_transect, n)
  names <- names(input_raster)
  route_table <- fcn_sample_point_to_route(extract_table, names)
  route_table_no_geom <- sf::st_drop_geometry(route_table)
  return(route_table_no_geom)
}

#' Route event layer to SF linestrings
#' Converts Route event layer (from fcn_route_table) to lines
#' @export
fcn_locate_feature_from_route <- function(route_table, line_transects) {
  state <- fcn_get_state()
  line_transect_simple <- line_transects %>%
    dplyr::select(TransectID, geometry)
  route_events <- dplyr::right_join(line_transect_simple, route_table, by = 'TransectID', relationship = "one-to-many")
  route_events_trimmed <- mapply(fcn_line_trim, sf::st_geometry(route_events),
                                 route_events[["FMEAS"]] / route_events[["Tlength"]],
                                 route_events[["TMEAS"]] / route_events[["Tlength"]]) %>%
    sf::st_sfc()
  sf::st_crs(route_events_trimmed) <- state$crs
  route_events_no_geometry <- sf::st_drop_geometry(route_events)
  df <- sf::st_sf(cbind(route_events_no_geometry, route_events_trimmed))
  return(df)
}

fcn_line_trim <- function(geom, start, end) {
  multipoint <- sf::st_line_sample(geom, sample = c(start, end))
  linestring <- sf::st_cast(multipoint, "LINESTRING")
  return(linestring)
}
